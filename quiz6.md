### Quiz Lecture 6

1. Кто может быть другом класса T?
- Свободная функция
- Другой класс
- ~~Метод другого класса~~

2. Какие возможности есть у друга класса T?
- Доступ к публичным полям и методам класса T
- Доступ к приватным полям класса Т
- Доступ к приватным методам класса Т
- ~~Доступ к приватным членам класса Y, для которого T является другом~~
3. Пусть дружественная функция определена внутри класса и вне класса нет ее объявления. Каким образом компилятор находит эту функцию в месте ее вызова?
```C++
struct X {
    friend void f() { std::cout << __func__; }
    friend void g(const X&) { std::cout << __func__; }
};
int main() {
    g(X{}); // (1) Ok
    f();    // (2) Compile error
    void f();
    f();    // (3) Ok
    return 0;
}
```
В первом случае используется ADL(Argument dependent lookup, Поиск Кёнига), компилятор видит, что аргументы ```g()``` принадлежат классу ```X``` и расширяет область поиска функции `g`, добавляя в неё класс `X`, во втором случае ```Compile Error```, чтобы не было ошибки компиляции, нужно снаружи класса определить функцию `f`.

4. (*) Я понимаю, что такое `Forward Declaration`

Рассмотрим такой код:
```C++
struct Object {
    Inventory *inventory;
};
struct Inventory {
    vector<Object *> items;
};
```
В данном случае возникает ошибка компиляции потому что на момент, когда создается класс Object компилятор ничего не знает о существовании типа `Inventory`. Чтобы этот код скомпилировался нужно перед объявлением поля класса `inventory` "задекларировать" класс `Inventory`:  
`class Inventory;` (это можно сделать прямо внутри класса `Object`)

Такой подход называется `Forward declaration` (declaration without complete definition).
    
Но декларации достаточно только для объявления указателя или ссылки на класс:
```
class A;
class B{
    A a_; // error: incomplete type
};
```
В случае, когда мы используем конкретный инстанс будет ошибка компиляции, так как тип `A` является `incomplete`
5. Выберите операторы, которые можно перегрузить?
-  `+`
-  `++`
-  `::` -- нельзя
-  `.*` -- нельзя
-  `~`
-  `,`

P.S. Также нельзя перегружать операторы `.` и `:?`(тернарный оператор)

6. Какие операторы могут быть определены только как члены класса?
- ```operator()```
- ```operator=```
- ```operator[]```
- ```operator->```
7. Обычно, для того, чтобы вывести строковое представление объекта класса Т используется operator<<. Почему это оператор не может быть методом класса?

Потому что все `not-static` методы класса принимают неявный аргумент `this`.
`operator<<` может быть методом класса, но тогда придется писать непривычный код, так как `this` передается первым аргументом:
```C++
my_vector v{1, 2, 3};
v << std::cout; // operator<<(v, std::cout);
```
Чтобы этого избежать `operator<<` определяют вне класса как внешнюю функцию с сигнатурой:
```C++
std::ostream& operator<<(std::ostream& os, const T& my_type);
```
8. Скомпилируется ли функция, возвращающая non-void, если return-statement отсутствует в ее теле.

да

9. Для чего нужна проверка if (this == &other) в операторе присваивания? (*) Что может пойти не так, если ею пренебречь?

Посмотрим на следующий код:
```C++
class X {
public:
    ~X() {...}
    X() {...}
    X& operator=(const X& other) {
      delete data_;
      data_ = other.data_;
    }
private:
int* data_;
};
```
Если пренебречь этой проверкой, то в случае, когда `this == &other` мы не только потрем все данные, которые лежат в `data_`, но и при выходе из скоупа и вызове деструктора вылетим с ошибкой `double free` из-за того, что два раза вызовем `delete` от одного и того же указателя. Исправить эту ошибку можно проверкой `if(this == &other)` или воспользовавшись `copy and swap` идиомой:

```C++
// the pass-by-value parameter serves as a temporary
String & operator = (String s) {
   s.swap (*this); // Non-throwing swap
   return *this; // Old resources released when destructor of s is called.
}
```
